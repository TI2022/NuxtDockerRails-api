FROM ruby:3.1.1-alpine
# Dockerfileには「コンテナをどのイメージから生成するか」を必ず記入しなければなりません。
# このイメージをベースイメージと呼び、FROM命令で指定します。
# Rubyのバージョンは開発時点の安定版を使用するようにしましょう。
# 以下の手順でバージョンを調べます。
# まず、Rails6に必要なRubyのバージョンを知る。
# Railsガイド => Ruby 2.5.0以降が必要
# 次にRuby 2.5.0以上の安定版を知る。
# Ruby => 安定版は 3.1.1
# 最後にRuby 3.1.1のベースイメージを調べる。
# Docker Hub => 3.1.1-alpineを採用
ARG WORKDIR
# ARG <変数名>
# Dockerfile内で使用する変数名を指定します。
# ここでは「WORKDIR」と言う変数名を宣言をしています。
# これから先「docker-compose.yml」内で指定しますが、先にネタバラシをすると、ここには「app」と言う文字列が入ります

ENV RUNTIME_PACKAGES="linux-headers libxml2-dev make gcc libc-dev nodejs tzdata postgresql-dev postgresql git" \
    DEV_PACKAGES="build-base curl-dev" \
    HOME=/${WORKDIR} \
    LANG=C.UTF-8 \
    TZ=Asia/Tokyo
# ENV <変数名=値>
# Dockerイメージで使用する環境変数を指定します。
# ENVを使って設定した環境変数は、イメージからコンテナへ渡されます。
# コンテナへ渡されると、コンテナ内で起動したアプリケーションで参照することができます。

# ENV test（このRUN命令は確認のためなので無くても良い）
RUN echo ${HOME}
# ベースイメージに対して何らかのコマンドを実行する場合に使用します。
# 例えば echo ${HOME} は「${展開した環境変数}」の文字列を出力しろ。と言うコマンドです。
# Dockerfile内で変数を展開する場合は、${変数名}、もしくは$変数名と書きます。

WORKDIR ${HOME}
# Dockerfileで定義した命令を実行する、コンテナ内の作業ディレクトリパスを指定します。
# ここで指定したディレクトリパスの中にRailsアプリが作成されます。

COPY Gemfile* ./
# COPY <ローカルのファイルパス> <Dokerイメージのファイルパス>
# ローカルファイルをイメージにコピーする命令です。
# ローカルファイルとは自分のPC上にあるファイルです。
# Gemfile*
# このアスタリスクは「Gemfileで始まるファイル名を全てコピーする」という指定になります。
# つまり、ローカルのGemfileとGemfile.lockを指定しています。
# ./
# コピー先のパスを絶対パス、もしくは相対パスで指定します。
# ここでは相対パスを指定していて、「WORKDIRの直下にコピー」されます。
# 絶対パスの場合は/appのように記入します。
# デフォルトのパスは/です。

RUN apk update && \
    apk upgrade && \
    apk add --no-cache ${RUNTIME_PACKAGES} && \
    apk add --virtual build-dependencies --no-cache ${DEV_PACKAGES} && \
    bundle install -j4 && \
    apk del build-dependencies
# apk
# Alpine Linuxのコマンドです。
# Linuxコマンドのapt-getが使用されている場合は、ベースイメージがAlpineでは無いと言う事です。
# 混乱しやすいところですが「Alpine = apkコマンド」と覚えておきましょう。
# apk update
# 利用可能なパッケージの最新リストを取得するためのコマンドです。
# apkコマンドでパッケージをインストールする場合、必ずと言っていいほど先頭に追加します。
# 「まず初めにupdateしてパッケージをインストールする」と覚えておきましょう。
# apk add コマンドの--update-cache オプションは、apk updateと同じく「利用可能なパッケージの最新のリストを取得するためのコマンド」のオプションバージョンです。
# apk updateを実行したのちにインストールするパッケージには、--update-cacheオプションを付ける必要はありません。
# インストールされているパッケージをアップグレードします。
# 当初、インストール後に実行すべきでは?と思いましたが、コマンドを確認するとインストール前に書いてもちゃんとアップグレードされていました。
# apk add
# パッケージをインストールするコマンドです。
# --no-casheオプション
# ローカルにキャッシュしないようにする、addコマンドのオプションです。
# コンテナを軽量に保つために使用します。
# --virtualオプション <名前>
# addコマンドのオプションです。
# このオプションを付けてインストールしたパッケージは、一まとめにされ、新たなパッケージとして扱うことができます。
# パッケージのパッケージ化、ヘルプでは「仮想パッケージ」と呼んでいます。
# この仮想パッケージを呼び出すには、指定した<名前>で呼び出します。
# ここではbuild-dependenciesと言う名前を付けています。
# 実行した後に削除する、いわゆる「使い捨てパッケージ」をインストールする場合に良く使われます。
# bundle install -j4
# Railsに必要なGemをインストールするためにbundle installコマンドを実行しています。
# -j4
# bundle installのオプションで、--jods=4の別名です。
# 並列処理でインストールが高速化されるって!!（初耳）
# apk del
# パッケージを削除するコマンドです。
# 先ほど--virtualオプションで指定した、仮想パッケージを一括削除しています。
# build-base とcurl-devはRailsの起動自体に必要ないので削除してんだね。

COPY . .
# COPY . .
# ローカルにある全てのファイルをイメージにコピーしています。
# それぞれ相対パスで指定しています。

# CMD ["rails", "server", "-b", "0.0.0.0"]
# Railsのサーバが起動しない「A server is already running. Check /tmp/pids/server.pid」のエラー対応の為、上記コメントアウト。
# CMD [実行したいコマンド]
# 生成されたコンテナ内で実行したいコマンドを指定します。
# Railsを起動するためのrails serverコマンドを実行しています。
# -b 0.0.0.0
# rails serverのコマンドオプションとなります。
# railsのプロセスをどのipアドレスにバインドするかを指定します。
# ここではlocalhostのipアドレス「127.0.0.1」を「0.0.0.0」にバインドしています。
# なぜこんな事をするのか?
# 仮想環境で起動したRailsは、localhostのipアドレス「127.0.0.1」でアクセスできません。
# そこで仮想外部からアクセスできるように、ip「0.0.0.0」に紐付けをする必要があるのです。
# これにより、自分のPC上のブラウザでRailsにアクセスできるようになるのです。